/**
 * {{projectName}} Health Check Worker
 * 
 * Provides comprehensive health monitoring and status reporting
 * Generated by PurAir Cloudflare Setup Tool
 * Created: {{timestamp}}
 */

// Health check configuration
const HEALTH_CONFIG = {
  service: '{{projectName}}',
  version: '{{version | default "1.0.0"}}',
  environment: '{{environment | default "production"}}',
  deploymentId: '{{deploymentId | default "unknown"}}',
  endpoints: {
    {{#each healthCheckEndpoints}}
    {{name}}: '{{url}}',
    {{/each}}
  },
  thresholds: {
    responseTime: {{responseTimeThreshold | default 1000}},
    errorRate: {{errorRateThreshold | default 0.05}},
    cpuUsage: {{cpuThreshold | default 0.80}},
    memoryUsage: {{memoryThreshold | default 0.80}}
  }
};

// Performance metrics storage
let performanceMetrics = {
  requestCount: 0,
  errorCount: 0,
  totalResponseTime: 0,
  lastReset: Date.now(),
  memoryPeak: 0,
  cpuSamples: []
};

// Health status cache
let healthStatus = {
  status: 'unknown',
  lastCheck: null,
  services: {},
  performance: {},
  configuration: {}
};

/**
 * Main request handler
 */
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  const url = new URL(request.url);
  const startTime = Date.now();
  
  try {
    // Update request metrics
    performanceMetrics.requestCount++;
    
    // Route requests
    switch (url.pathname) {
      case '/health':
        return await handleHealthCheck(request);
      case '/health/detailed':
        return await handleDetailedHealth(request);
      case '/health/metrics':
        return await handleMetrics(request);
      case '/health/config':
        return await handleConfigCheck(request);
      case '/health/reset':
        return await handleReset(request);
      default:
        return new Response('Health Check Service\n\nEndpoints:\n- /health - Basic health status\n- /health/detailed - Detailed health report\n- /health/metrics - Performance metrics\n- /health/config - Configuration validation\n- /health/reset - Reset metrics', {
          status: 200,
          headers: { 'Content-Type': 'text/plain' }
        });
    }
  } catch (error) {
    // Track errors
    performanceMetrics.errorCount++;
    
    return new Response(JSON.stringify({
      status: 'error',
      error: {
        message: 'Internal health check error',
        timestamp: new Date().toISOString()
      }
    }), {
      status: 500,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      }
    });
  } finally {
    // Track response time
    const responseTime = Date.now() - startTime;
    performanceMetrics.totalResponseTime += responseTime;
  }
}

/**
 * Basic health check endpoint
 */
async function handleHealthCheck(request) {
  const status = await performHealthCheck();
  
  return new Response(JSON.stringify({
    status: status.overall,
    service: HEALTH_CONFIG.service,
    version: HEALTH_CONFIG.version,
    environment: HEALTH_CONFIG.environment,
    timestamp: new Date().toISOString(),
    uptime: getUptime(),
    responseTime: getAverageResponseTime()
  }), {
    status: status.overall === 'healthy' ? 200 : 503,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
      'Cache-Control': 'no-cache, no-store, must-revalidate'
    }
  });
}

/**
 * Detailed health check with all metrics
 */
async function handleDetailedHealth(request) {
  const health = await performHealthCheck();
  const metrics = getPerformanceMetrics();
  const config = await validateConfiguration();
  
  const detailedReport = {
    status: health.overall,
    service: HEALTH_CONFIG.service,
    version: HEALTH_CONFIG.version,
    environment: HEALTH_CONFIG.environment,
    deploymentId: HEALTH_CONFIG.deploymentId,
    timestamp: new Date().toISOString(),
    uptime: getUptime(),
    
    // Service health
    services: health.services,
    
    // Performance metrics
    performance: {
      ...metrics,
      thresholds: HEALTH_CONFIG.thresholds,
      alerts: checkPerformanceAlerts(metrics)
    },
    
    // Configuration status
    configuration: config,
    
    // System information
    system: {
      userAgent: request.headers.get('User-Agent'),
      acceptLanguage: request.headers.get('Accept-Language'),
      cfRay: request.headers.get('CF-Ray'),
      cfConnectingIp: request.headers.get('CF-Connecting-IP'),
      cfCountry: request.headers.get('CF-IPCountry')
    }
  };
  
  return new Response(JSON.stringify(detailedReport, null, 2), {
    status: health.overall === 'healthy' ? 200 : 503,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*',
      'Cache-Control': 'no-cache, no-store, must-revalidate'
    }
  });
}

/**
 * Performance metrics endpoint
 */
async function handleMetrics(request) {
  const metrics = getPerformanceMetrics();
  
  return new Response(JSON.stringify({
    service: HEALTH_CONFIG.service,
    timestamp: new Date().toISOString(),
    metrics,
    alerts: checkPerformanceAlerts(metrics)
  }), {
    status: 200,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*'
    }
  });
}

/**
 * Configuration validation endpoint
 */
async function handleConfigCheck(request) {
  const config = await validateConfiguration();
  
  return new Response(JSON.stringify({
    service: HEALTH_CONFIG.service,
    timestamp: new Date().toISOString(),
    configuration: config
  }), {
    status: config.valid ? 200 : 400,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*'
    }
  });
}

/**
 * Reset metrics endpoint
 */
async function handleReset(request) {
  // Security check - only allow reset from specific origins or with auth
  const origin = request.headers.get('Origin');
  const authHeader = request.headers.get('Authorization');
  
  {{#if resetAuthRequired}}
  if (!authHeader || !authHeader.startsWith('Bearer {{resetToken}}')) {
    return new Response('Unauthorized', { status: 401 });
  }
  {{/if}}
  
  // Reset metrics
  performanceMetrics = {
    requestCount: 0,
    errorCount: 0,
    totalResponseTime: 0,
    lastReset: Date.now(),
    memoryPeak: 0,
    cpuSamples: []
  };
  
  return new Response(JSON.stringify({
    message: 'Metrics reset successfully',
    timestamp: new Date().toISOString()
  }), {
    status: 200,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*'
    }
  });
}

/**
 * Perform comprehensive health check
 */
async function performHealthCheck() {
  const services = {};
  let overallHealthy = true;
  
  // Check configured endpoints
  {{#if healthCheckEndpoints}}
  for (const [name, endpoint] of Object.entries(HEALTH_CONFIG.endpoints)) {
    try {
      const startTime = Date.now();
      const response = await fetch(endpoint, {
        method: 'GET',
        headers: {
          'User-Agent': 'PurAir-HealthCheck/1.0',
          'Accept': 'application/json'
        },
        signal: AbortSignal.timeout(5000) // 5 second timeout
      });
      
      const responseTime = Date.now() - startTime;
      const isHealthy = response.status >= 200 && response.status < 400;
      
      services[name] = {
        status: isHealthy ? 'healthy' : 'unhealthy',
        statusCode: response.status,
        responseTime,
        lastCheck: new Date().toISOString()
      };
      
      if (!isHealthy) overallHealthy = false;
      
    } catch (error) {
      services[name] = {
        status: 'error',
        error: error.message,
        lastCheck: new Date().toISOString()
      };
      overallHealthy = false;
    }
  }
  {{/if}}
  
  // Check API connectivity if configured
  {{#if apiType}}
  {{#if (eq apiType "airtable")}}
  if (typeof AIRTABLE_API_KEY !== 'undefined' && typeof AIRTABLE_BASE_ID !== 'undefined') {
    services.airtable = await checkAirtableHealth();
    if (services.airtable.status !== 'healthy') overallHealthy = false;
  }
  {{/if}}
  {{/if}}
  
  // Check performance thresholds
  const metrics = getPerformanceMetrics();
  const performanceHealthy = checkPerformanceHealth(metrics);
  if (!performanceHealthy) {
    overallHealthy = false;
    services.performance = {
      status: 'degraded',
      issues: checkPerformanceAlerts(metrics),
      lastCheck: new Date().toISOString()
    };
  }
  
  return {
    overall: overallHealthy ? 'healthy' : 'unhealthy',
    services
  };
}

/**
 * Check Airtable API health
 */
{{#if (eq apiType "airtable")}}
async function checkAirtableHealth() {
  try {
    const response = await fetch(`https://api.airtable.com/v0/${AIRTABLE_BASE_ID}`, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${AIRTABLE_API_KEY}`,
        'User-Agent': 'PurAir-HealthCheck/1.0'
      },
      signal: AbortSignal.timeout(5000)
    });
    
    return {
      status: response.status === 200 ? 'healthy' : 'unhealthy',
      statusCode: response.status,
      lastCheck: new Date().toISOString()
    };
  } catch (error) {
    return {
      status: 'error',
      error: 'Connection failed',
      lastCheck: new Date().toISOString()
    };
  }
}
{{/if}}

/**
 * Get current performance metrics
 */
function getPerformanceMetrics() {
  const uptime = getUptime();
  const avgResponseTime = getAverageResponseTime();
  const errorRate = performanceMetrics.requestCount > 0 
    ? performanceMetrics.errorCount / performanceMetrics.requestCount 
    : 0;
  
  return {
    uptime,
    requestCount: performanceMetrics.requestCount,
    errorCount: performanceMetrics.errorCount,
    errorRate: Math.round(errorRate * 10000) / 10000, // 4 decimal places
    averageResponseTime: avgResponseTime,
    requestsPerSecond: uptime > 0 ? Math.round((performanceMetrics.requestCount / uptime) * 100) / 100 : 0,
    memoryUsage: getMemoryUsage(),
    lastReset: new Date(performanceMetrics.lastReset).toISOString()
  };
}

/**
 * Check performance against thresholds
 */
function checkPerformanceHealth(metrics) {
  const thresholds = HEALTH_CONFIG.thresholds;
  
  return (
    metrics.averageResponseTime <= thresholds.responseTime &&
    metrics.errorRate <= thresholds.errorRate &&
    metrics.memoryUsage <= thresholds.memoryUsage
  );
}

/**
 * Generate performance alerts
 */
function checkPerformanceAlerts(metrics) {
  const alerts = [];
  const thresholds = HEALTH_CONFIG.thresholds;
  
  if (metrics.averageResponseTime > thresholds.responseTime) {
    alerts.push({
      type: 'response_time',
      severity: 'warning',
      message: `Average response time (${metrics.averageResponseTime}ms) exceeds threshold (${thresholds.responseTime}ms)`
    });
  }
  
  if (metrics.errorRate > thresholds.errorRate) {
    alerts.push({
      type: 'error_rate',
      severity: 'critical',
      message: `Error rate (${(metrics.errorRate * 100).toFixed(2)}%) exceeds threshold (${(thresholds.errorRate * 100).toFixed(2)}%)`
    });
  }
  
  if (metrics.memoryUsage > thresholds.memoryUsage) {
    alerts.push({
      type: 'memory_usage',
      severity: 'warning',
      message: `Memory usage (${(metrics.memoryUsage * 100).toFixed(1)}%) exceeds threshold (${(thresholds.memoryUsage * 100).toFixed(1)}%)`
    });
  }
  
  return alerts;
}

/**
 * Validate worker configuration
 */
async function validateConfiguration() {
  const issues = [];
  let valid = true;
  
  // Check required environment variables
  {{#if requiredEnvVars}}
  const requiredVars = [{{#each requiredEnvVars}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}];
  for (const varName of requiredVars) {
    if (typeof globalThis[varName] === 'undefined') {
      issues.push({
        type: 'missing_env_var',
        severity: 'error',
        message: `Missing required environment variable: ${varName}`
      });
      valid = false;
    }
  }
  {{/if}}
  
  // Check API configuration
  {{#if (eq apiType "airtable")}}
  if (typeof AIRTABLE_API_KEY === 'undefined' || typeof AIRTABLE_BASE_ID === 'undefined') {
    issues.push({
      type: 'api_config',
      severity: 'error',
      message: 'Airtable API configuration incomplete'
    });
    valid = false;
  }
  
  if (typeof AIRTABLE_API_KEY !== 'undefined' && AIRTABLE_API_KEY.length < 10) {
    issues.push({
      type: 'api_config',
      severity: 'warning',
      message: 'Airtable API key appears to be invalid'
    });
  }
  {{/if}}
  
  // Check CORS configuration
  {{#if corsEnabled}}
  if (typeof ALLOWED_ORIGINS === 'undefined') {
    issues.push({
      type: 'cors_config',
      severity: 'warning',
      message: 'CORS enabled but no allowed origins defined'
    });
  }
  {{/if}}
  
  return {
    valid,
    issues,
    checkedAt: new Date().toISOString()
  };
}

/**
 * Helper functions
 */
function getUptime() {
  return Math.floor((Date.now() - performanceMetrics.lastReset) / 1000);
}

function getAverageResponseTime() {
  return performanceMetrics.requestCount > 0 
    ? Math.round(performanceMetrics.totalResponseTime / performanceMetrics.requestCount)
    : 0;
}

function getMemoryUsage() {
  // Estimate memory usage (Cloudflare Workers have limited introspection)
  const memoryEstimate = JSON.stringify(performanceMetrics).length + 
                        JSON.stringify(healthStatus).length + 
                        JSON.stringify(HEALTH_CONFIG).length;
  
  // Very rough estimate - assume 128MB limit
  return Math.min(memoryEstimate / (128 * 1024 * 1024), 1.0);
}

// Handle CORS preflight requests
addEventListener('fetch', event => {
  if (event.request.method === 'OPTIONS') {
    event.respondWith(handleOptions(event.request));
  }
});

function handleOptions(request) {
  return new Response(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      'Access-Control-Max-Age': '86400'
    }
  });
}